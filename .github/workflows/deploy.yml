name: Deploy Django to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: eu-west-2
  EB_APPLICATION_NAME: LGU2-Front-End
  EB_ENVIRONMENT_NAME: LGU2-Front-End
  S3_BUCKET: lgu2-code
  STATIC_S3_BUCKET: lgu2-django-static

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true
        installer-parallel: true

    - name: Install Poetry Export Plugin
      run: poetry self add poetry-plugin-export

    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --only main

    - name: Export requirements
      run: poetry export --without dev -f requirements.txt --output requirements.txt

    - name: Collect static files
      run: |
        poetry run python manage.py collectstatic --noinput --settings=lgu2.settings
      env:
        SECRET_KEY: dummy-key-for-collectstatic
        API_BASE_URL: dummy-url-for-collectstatic

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Upload static files to S3
      run: |
        aws s3 sync staticfiles/ s3://${{ env.STATIC_S3_BUCKET }}/ --delete

    - name: Create deployment package
      run: |
        timestamp=$(date +%Y%m%d%H%M%S)
        zip_name="django-${timestamp}.zip"
        echo "ZIP_NAME=${zip_name}" >> $GITHUB_ENV

        # Create deployment package excluding development files
        zip -r $zip_name . \
          -x "poetry.lock" \
          -x "pyproject.toml" \
          -x "staticfiles/*"

    - name: Upload to S3
      run: |
        aws s3 cp ${{ env.ZIP_NAME }} s3://${{ env.S3_BUCKET }}/django/

    - name: Create new Elastic Beanstalk version
      run: |
        version_label="django-$(date +%Y%m%d%H%M%S)"
        echo "VERSION_LABEL=${version_label}" >> $GITHUB_ENV

        aws elasticbeanstalk create-application-version \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --version-label ${version_label} \
          --source-bundle S3Bucket=${{ env.S3_BUCKET }},S3Key=django/${{ env.ZIP_NAME }} \
          --description "GitHub Actions deployment at $(date)" \
          --process

        aws elasticbeanstalk describe-application-versions \
          --application-name "${{ env.EB_APPLICATION_NAME }}" \
          --version-label "${version_label}" \
          --query 'ApplicationVersions[0].Status' --output text

    # - name: Set EB managed update policy
    #   run: |
    #     # 1) Re-assert managed updates wiring (idempotent)
    #     aws elasticbeanstalk update-environment \
    #       --application-name "$EB_APPLICATION_NAME" \
    #       --environment-name "$EB_ENVIRONMENT_NAME" \
    #       --option-settings \
    #         Namespace=aws:elasticbeanstalk:managedactions,OptionName=ServiceRoleForManagedUpdates,Value=AWSServiceRoleForElasticBeanstalkManagedUpdates \
    #         Namespace=aws:elasticbeanstalk:managedactions,OptionName=ManagedActionsEnabled,Value=true \
    #         Namespace=aws:elasticbeanstalk:managedactions,OptionName=PreferredStartTime,Value=Tue:09:00 \
    #         Namespace=aws:elasticbeanstalk:managedactions:platformupdate,OptionName=UpdateLevel,Value=patch

    #     # 2) Wait until that config update is fully applied
    #     aws elasticbeanstalk wait environment-updated \
    #       --environment-names "$EB_ENVIRONMENT_NAME"

    - name: Deploy to Elastic Beanstalk
      run: |
        aws elasticbeanstalk update-environment \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --environment-name ${{ env.EB_ENVIRONMENT_NAME }} \
          --version-label ${{ env.VERSION_LABEL }}

    - name: Wait for deployment
      run: |
        echo "Waiting for deployment to complete..."
        aws elasticbeanstalk wait environment-updated \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --environment-name ${{ env.EB_ENVIRONMENT_NAME }}

        # Get the final status
        status=$(aws elasticbeanstalk describe-environments \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --environment-names ${{ env.EB_ENVIRONMENT_NAME }} \
          --query 'Environments[0].Health' --output text)

        echo "Deployment completed with status: $status"

        if [ "$status" != "Green" ]; then
          echo "Deployment failed with status: $status"
          exit 1
        fi

    - name: Get deployment URL
      run: |
        url=$(aws elasticbeanstalk describe-environments \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --environment-names ${{ env.EB_ENVIRONMENT_NAME }} \
          --query 'Environments[0].CNAME' --output text)
        echo "Application deployed at: https://$url"
